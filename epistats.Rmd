---
title: "Epistats"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### __2021-07-27__
## Overview
```{r loadpkg, warning=FALSE}
library(epistats)
```
**Epistats** is a new tool developed in R aimed to extract epialleles distributions from RRBS sequencing data. The analysis is now described looking at the CpG methylation, but the tool is flexible and it can also be used to get information from CH methylation.

The functions contained in epistats can be divided in three classes: 

* Loading and filtering:

  These functions prepare the files used for the analysis, the BAM file and the FASTA genome:
  + loadInput(): This function read in the R environment the bam file and the genome file and it matches their seqlevels. 
  + filterBAM(): This function filter the alignment object by removing the regions that do not have to be analyzed 


* Regions design: 

  The package contains other three functions that are needed to design the genomic intervals to extract the epialleles information from. 
  
  + filterByCoverage(): This function finds the genomic regions that are sufficiently covered in the given RRBS experiment. 
  + makeEpialleles(): This function takes as input the genomic intervals covered in the experiement and it designs genomic intervals with different lengths containing 4 CpGs. 
  + makeWindows(): This function acts as the previous one, but designing genomic intervals that are sliding windows of a given length. 

* Epialleles extraction: 

  + epiAnalysis()

* Statistics: 

  + epiStat()
  + pairtest() 
  + epidiv()
  + epiplot()
  
### Workflow

#### 1. **Data loading** 

The first thing you need to perform is the loading of your data. To perform the epialleles analysis you need the BAM file storing the aligned reads from the RRBS sequencing and a FASTA genome file. 
The __loadInput()__ function loads both files that need to be provided from the user as paths and it returns a list containing:

* A GAlignment object containing the alignments 
* A DNAStringSet containing the reference genome sequence 


```{r loadAlignment, results='hide'}
bamfile <- "/home/condivisa_giulia/CML/out/ERR1227470_sorted.bam"
genomefile <- "/home/deriso/analysis/Genome/hg19/GRCh37.p13.genome.fa"
data <- loadInput(bamfile = bamfile, genomefile = genomefile)
```

To get the GAlignment object alone, subset your 'data' previously generated by using double square brackets as described below:

```{r}
algn <- data[[1]]
knitr::kable(head(algn))
```
To get the DNAStringSet containing the reference genome sequences by chromosomes, use double square brackets to get the second element of the list.


```{r loadGenome}
Genome <- data[[2]]
Genome
```
#### 2. **Filtering data**

After loading the data, the user can decide to filter the GAlignment object in order to exclude some regions from the analysis. 
The __filterBAM()__ function can be used to select only standard chromosomes from the GAlignment object, to remove/retain the mitochondrial chromosome or to specify given chromosomes that can be provided by the user as vector through the __retainChr__ parameter. 

Your GAlignment object will probably contain several seqlevels, many of them referring to contings elements 

```{r, message=FALSE}
library(GenomeInfoDb)
```

```{r}
seqlevels(algn)
```
You can decide to filter the GAlignment object in order to select only standard chromosomes to perform the analysis. 

```{r, results='hide'}
algn <- filterBAM(algn = algn, 
                 keepStChr = TRUE, 
                 keepM = FALSE, 
                 retainChr = NULL)
```
```{r}
seqlevels(algn)
```


#### 3. **Filtering only covered regions** 

Another filtering step is performed through the __filterByCoverage()__ function. In this step the user specifically selects the GenomicRanges that are covered enough in the RRBS experiment. The minimum coverage wanted to perform the analysis can be set through the __threshold__ parameter.
The additional __minsize__ parameter can be used to set the minimum length size of genomic intervals. This should correspond to the maximum read length of a RRBS experiment, since you need your reads to be completely contained in your analyzed interval. 

```{r, results='hide'}
gr <- filterByCoverage(algn = algn, 
                       threshold = 50, 
                       minsize = 50)
```
```{r}
gr
```


#### 4. **Defining GenomicRanges to analyse** 

Once defined the GenomicRanges that satisfy the user coverage requirements, the next step is aimed to design the genomic intervals for the extraction of epialleles information. 
At this point, you can decide among two different methods: 

* The __makeEpialleles()__ function is used to create GenomicRanges of
  different length, but containing a defined number of CpG set by the user
  through the parameter __n__.
  The output is a list containing the following elements:
  + A GRanges object which contains the genomic ranges to analyse.
  + A GRanges object which contains the coordinates of the CpG contained in        these regions.

* The __makeWindows()__ function is used to create GenomicRanges that are
  sliding windows across the covered genomic regions of given __window__ and
  __step__ length sizes. As described above, the output of this function will
  be a function containing two different GRanges objects ( __see Above__ ).
  
  
```{r, results='hide'}
regions <- makeEpialleles(gr = gr, 
                       Genome = Genome, 
                       mode = "CG", 
                       n = 4, 
                       min.binsize = 8,
                       max.binsize = 50, 
                       cores = 10)
```
```{r}
bins <- regions$bins
bins
```


```{r}
cg <- regions$c_pos
cg
```
```{r}
windows <- makeWindows(gr = gr, 
                       window = 50, 
                       step = 1, 
                       Genome = Genome, 
                       mode = "CG", 
                       min.C = 2, 
                       max.C = 10, 
                       cores = 10)

slidingwindows <- windows$windows
slidingwindows
```
```{r}
cg <- windows$c_pos
cg
```
#### 5. **Extracting epialleles** 

The __epiAnalysis()__ function basically works in the following steps:

* It stacks the reads contained in the GAlignment object over the genomic
  ranges defined by the functions __makeEpialleles()__ and __makeWindows()__. 

* It looks for the CpG positions in the reference Genome and then it checks the
  methylation status of the C in those positions in the reads. 

* It builds a binary matrix where 0 stands for the unmethylated status and 1
  for the methylated status. 

* It applies over this matrix a list of functions that can be provided by the
  user to perform some statistics that will be shown in one of the output as
  dataframe columns. 
  
* It can exclude from the epialleles analysis those reads which bisulfite conversion efficiency was under a threshold given as parameter through __bisu.Thresh__.

```{r}
dist= function(matrix){
  Cpos=as.numeric(names(matrix))
  dist=round(mean(Cpos[-1]-Cpos[-length(Cpos)])/length(Cpos),2)
  return(dist)
}

epi= function(matrix){
  matrix$epi= apply(matrix, 1, function(x) paste(x, collapse = ""))
  matrix= as.data.frame(table(matrix$epi))
  epi=nrow(matrix)
  return(epi)
}

singleton= function(matrix){
  matrix$epi= apply(matrix, 1, function(x) paste(x, collapse = ""))
  matrix= as.data.frame(table(matrix$epi))
  singleton= length(matrix$Freq[matrix$Freq==1])
  return(singleton)
}

mean_met= function(matrix){
  mean_met=round(sum(as.matrix(matrix),na.rm=T)/(dim(matrix)[1]*dim(matrix)[2]),2)
  return(mean_met)
}

num_cg= function(matrix){
  num_cg=ncol(matrix)
  return(num_cg)
}

num_reads= function(matrix){
  num_reads=nrow(matrix)
  return(num_reads)
}

maxfreq= function(matrix){
  matrix$epi= apply(matrix, 1, function(x) paste(x, collapse = ""))
  matrix= as.data.frame(table(matrix$epi))
  maxfreq=paste(matrix[matrix$Freq==max(matrix$Freq),1],sep=",")
  return(maxfreq)
}

shannon= function(matrix){
  matrix$epi= apply(matrix, 1, function(x) paste(x, collapse = ""))
  matrix= as.data.frame(table(matrix$epi))
  prop= matrix$Freq/sum(matrix$Freq)
  shannon=round(-sum(prop * log2(prop), na.rm=T),2)
  return(shannon)
}

myfuns=list("dist"=dist,
            "epi"=epi, 
            "singleton"=singleton, 
            "maxfreq"=maxfreq,
            "shannon"=shannon,
            "mean_met"=mean_met,
            "num_cg"=num_cg,
            "num_reads"=num_reads)
```



```{r error=TRUE}
wd = "/home/sarnataro"

aname = "ERR1227470"

out = epiAnalysis(align = algn, 
                  bin = bins, 
                  bisu.Thresh = 0,
                  stranded = FALSE, 
                  mode = "CG",
                  remove.Amb = TRUE, 
                  genome = Genome, 
                  pathDir = wd, 
                  cores = 50, 
                  retain.reads = TRUE, 
                  get.cPos = FALSE,
                  myfuns = myfuns)

```
