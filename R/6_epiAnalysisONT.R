#' Extracting epiallele information from customised target regions.
#'
#' @description
#' This function takes a user-defined set of genomic regions (in the form of a 
#' GRanges object) and extracts, for each interval, the epiallele composition and 
#' summary statistics such as average methylation, Shannon entropy, epiallele 
#' diversity, etc.
#'
#' The function works on the sparse matrix generated by `loadInputONT()`, where 
#' rows correspond to reads and columns correspond to genomic positions. For each 
#' region, the corresponding submatrix is extracted, optionally separated by 
#' strand, converted to binary epialleles, and summarised.
#'
#' @importFrom foreach foreach %do% %dopar%
#' @importFrom Biostrings vmatchPattern matchPattern reverseComplement DNAString strsplit
#' @importFrom GenomicRanges GRanges
#' @importFrom IRanges IRanges subsetByOverlaps
#' @importFrom magrittr %>%
#' @importFrom parallel makeCluster stopCluster
#' @importFrom doParallel registerDoParallel
#' @param sparseMat 
#' A sparse matrix (dgCMatrix) generated by `loadInputONT()`, where rows are reads 
#' and columns are genomic motif positions (e.g. CpGs) encoded as `"chr_pos"`.
#' @param bins 
#' A `GRanges` object defining the target genomic intervals. Typically generated 
#' using `makeWindows()` or `makeBins()`.
#' @param code_map_epiallele 
#' Named integer vector defining how the sparse matrix values (e.g. 1, 2, 3) 
#' should be converted into binary epialleles (e.g. unmethylated = 0, methylated = 1).
#' @param stranded 
#' Logical indicating whether the analysis should be performed in strand-specific 
#' mode (`TRUE`) or by merging both strands (`FALSE`). Default: `FALSE`.
#' @param threshold 
#' Minimum number of reads required for a region to be analysed. Regions with 
#' total coverage below this threshold are discarded and reported in the log.
#' @param myfuns 
#' A named list of functions to compute summary statistics on the binary 
#' epiallele matrix (e.g. mean methylation, Shannon entropy, number of epialleles).
#' @param sample_name 
#' Character string indicating the sample name used for labelling outputs.
#' @param pathDir 
#' Directory in which results will be saved. If `NULL`, results are returned but 
#' not written to disk.
#' @param cores 
#' Integer specifying the number of CPU cores used for parallel processing.
#' @return 
#' A list with the following components:
#' \itemize{
#'   \item **intervals** — Data frame where each row corresponds to a processed 
#'   genomic region, containing summary statistics produced by `myfuns`.
#'
#'   \item **epi** — Data frame containing compressed epiallele composition for 
#'   each region (e.g. epiallele sequences and their frequencies).
#'
#'   \item **log** — Data frame listing genomic intervals that did not satisfy 
#'   minimum coverage requirements or were otherwise excluded.
#' }
#' @export


epiAnalysisONT= function(
                      sparseMat,
                      bins,
                      code_map_epiallele = c(`1`= 0, `2`= 1, `3`= 0),
                      stranded=FALSE,
                      threshold,
                      myfuns,
                      sample_name,
                      pathDir,
                      cores = 1)
{
  
  if (!methods::is(sparseMat, "dgCMatrix")) {
    stop("Input must be a sparse dgCMatrix")
  }
  
  values <- abs(sparseMat@x)
  uniq_vals <- sort(unique(values))
  
  if (!all(as.character(uniq_vals) %in% names(code_map_epiallele))) {
    stop("Some matrix values do not appear in `code_map_epiallele`.\n",
         "Missing: ", paste(setdiff(as.character(uniq_vals),
                                    names(code_map_epiallele)), collapse=", "))
  }
  
  df <- data.frame(bins)[,1:3]
  message('Dividing region table into ', cores, ' tables with ~', round(nrow(df)/cores), ' rows...')
  df_split <- split(df, (seq(nrow(df))-1) %/% (nrow(df)/cores))
  
  
  message('Dividing input sparseMat into ', cores, ' sparse matrices...')
  base_gr <- prepareSparseIndex(sparseMat)
  idx <- 0
  regs <- foreach::foreach (dfi = df_split) %do% {
    idx <- idx + 1
    message("Processing chunk ", idx, "/", length(df_split))
    
    regions <- dfi %>% group_by(seqnames) %>% summarize(start = min(start), end = max(end))
    subsetSparseByRegions(sparseMat, base_gr, regions)
  }
    
  strand_mode <- ifelse(stranded, 'stranded', 'unstranded')
  message('Extracting epialleles in ', strand_mode, ' mode using ', cores, ' cores...')
  cl <- parallel::makeCluster(cores, type = 'PSOCK')
  doParallel::registerDoParallel(cl)
  Mapi = tryCatch(
    {
      foreach::foreach(
        dfi = df_split,
        sparseMati = regs,
        .packages = c("Matrix","GenomicRanges","IRanges","data.table"),
        .export   = c("epiallele_analyse_ont", "prepareSparseIndex",
                      "encodeEpiallele", "get_out_ont", "subsetSparseByRegions",
                      "code_map_epiallele", "stranded", "threshold", "myfuns")
      ) %dopar% {
        sparseMati_gr <- prepareSparseIndex(sparseMati)
        ret_list <- vector("list", nrow(dfi))
        for (i in seq_len(nrow(dfi))) {
          ret_list[[i]] <- epiallele_analyse_ont(
            sparseMati        = sparseMati,
            sparseMati_gr     = sparseMati_gr,
            bin               = dfi[i,],
            code_map_epiallele = code_map_epiallele,
            stranded          = stranded,
            threshold         = threshold,
            myfuns            = myfuns
          )
        }
        ret_list
      }
    },
    finally = {
      parallel::stopCluster(cl)
      foreach::registerDoSEQ()  
    }
  )
  
  message('Extracting results for sample ', sample_name, '...')
  Mapi_flat <- do.call(c, Mapi)
  intervals <- data.table::rbindlist(lapply(Mapi_flat, `[[`, "intervals"), use.names = TRUE, fill = TRUE)
  epi       <- data.table::rbindlist(lapply(Mapi_flat, `[[`, "epi"),       use.names = TRUE, fill = TRUE)
  log       <- data.table::rbindlist(lapply(Mapi_flat, `[[`, "log"),       use.names = TRUE, fill = TRUE)
  
  
  message('Saving results for sample ', sample_name, ' in' , pathDir,  ' folder...')
  
  data.table::fwrite(intervals,
         file = file.path(pathDir, paste0(sample_name, "_intervals.bed")),
         sep = "\t")
  
  data.table::fwrite(epi,
         file = file.path(pathDir, paste0(sample_name, "_epiAnalysis.txt")),
         sep = "\t")
  
  data.table::fwrite(log,
         file = file.path(pathDir, paste0(sample_name, "_log.txt")),
         sep = "\t",
         col.names = FALSE)
  
  message('Analysis completed for', sample_name, '!')
  
  return(list('intervals' = intervals,
              'epi' = epi,
              'log' = log))
}


prepareSparseIndex <- function(sparseMat) {
  parts <- data.table::tstrsplit(colnames(sparseMat), "_", fixed = TRUE)
  chr_vec <- parts[[1]]
  pos_vec <- as.integer(parts[[2]])
  
  GRanges(seqnames = chr_vec, ranges = IRanges(pos_vec, width = 1))
}


subsetSparseByRegions <- function(sparseMat, base_gr, regions) {
  
  regions_gr <- GenomicRanges::makeGRangesFromDataFrame(
    as.data.frame(regions),
    keep.extra.columns = FALSE
  )
  
  # colonne che cadono nelle regioni
  ov <- GenomicRanges::findOverlaps(base_gr, regions_gr, ignore.strand = TRUE)
  cols_keep <- sort(unique(S4Vectors::queryHits(ov)))
  
  if (length(cols_keep) == 0L) {
    warning("Any column of your matrix falls into the selected regions.")
    return(sparseMat[, 0, drop = FALSE])
  }
  
  f_sparseMat <- sparseMat[, cols_keep, drop = FALSE]
  
  nonzero_rows <- Matrix::rowSums(f_sparseMat != 0) > 0
  final_sparseMat <- f_sparseMat[nonzero_rows, , drop = FALSE]
  
  return(final_sparseMat)
}


epiallele_analyse_ont <- function(
                           sparseMati,
                           sparseMati_gr,
                           bin,
                           code_map_epiallele,
                           stranded,
                           threshold,
                           myfuns){
  
  out=list("intervals"=data.frame(),"epi"=data.frame(),"log"=data.frame())
  
  if (!methods::is(sparseMati, "dgCMatrix")) {
    stop("`sparseMati` must be a Matrix::dgCMatrix object.")
  }
  if (nrow(sparseMati) == 0L || ncol(sparseMati) == 0L) {
    out$log <- rbind(out$log, as.data.frame(bin))
    return(out)
  }
  
  sparseMati_in_bin <- subsetSparseByRegions(sparseMati, sparseMati_gr, bin)
  
  ## Remove reads that contain zeros --> cannot determine full pattern
  f_sparseMati_in_bin <- sparseMati_in_bin[Matrix::rowSums(sparseMati_in_bin == 0) == 0, , drop = FALSE]
  
  if (nrow(f_sparseMati_in_bin) < threshold) {
    out$log <- as.data.frame(bin)
    return(out)
  }
  
  ## ---------------------------
  ## STRANDED MODE
  ## ---------------------------
  if (stranded){
    
    ## Separate + and -
    sparseMati_plus <- f_sparseMati_in_bin[Matrix::rowSums(f_sparseMati_in_bin) > 0, , drop = FALSE]
    sparseMati_minus <- abs(f_sparseMati_in_bin[Matrix::rowSums(f_sparseMati_in_bin) < 0, , drop = FALSE]) 
    
    if (nrow(sparseMati_plus) == 0 & nrow(sparseMati_minus) == 0) {
      out$log <- as.data.frame(bin)
      return(out)
    }
    
    ## If both empty -> log
    if (nrow(sparseMati_plus) == 0 && nrow(sparseMati_minus) == 0) {
      out$log <- as.data.frame(bin)
      return(out)
    }
    
    ## ---- PLUS STRAND ----
    if (nrow(sparseMati_plus) > 0) {
      epi_mat_plus <- encodeEpiallele(sparseMati_plus, code_map_epiallele)
      colnames(epi_mat_plus) <- as.numeric(sub(".*_", "", colnames(epi_mat_plus)))
      
      out_plus <- get_out_ont(epi_mat_plus, out = list(), strand="+", coord=bin, myfuns)
      out$epi       <- rbind(out$epi, out_plus$epi)
      out$intervals <- rbind(out$intervals, out_plus$intervals)
      out$log       <- rbind(out$log, out_plus$log)
    }
    
    ## ---- MINUS STRAND ----
    if (nrow(sparseMati_minus) > 0) {
      epi_mat_minus <- encodeEpiallele(sparseMati_minus, code_map_epiallele)
      colnames(epi_mat_minus) <- as.numeric(sub(".*_", "", colnames(epi_mat_minus)))
      
      out_minus <- get_out_ont(epi_mat_minus, out = list(), strand="-", coord=bin, myfuns)
      out$epi       <- rbind(out$epi, out_minus$epi)
      out$intervals <- rbind(out$intervals, out_minus$intervals)
      out$log       <- rbind(out$log, out_minus$log)
    }
  
  } else {
    ## ---------------------------
    ## NON–STRANDED MODE
    ## ---------------------------  
    sparseMati_both <- abs(f_sparseMati_in_bin)
    
    epi_mat_both <- encodeEpiallele(sparseMat = sparseMati_both,
                                    code_map_epiallele = code_map_epiallele)
    
    colnames(epi_mat_both) <- as.numeric(sub(".*_", "", colnames(epi_mat_both)))
    out <- get_out_ont(epi_mat_both, out = out, strand = "*", coord = bin, myfuns = myfuns)
  }
  
  return(out)
}


encodeEpiallele <- function(sparseMat,
                            code_map_epiallele = c(`1` = 0, `2` = 1, `3` = 0)) {
  
  if (!methods::is(sparseMat, "dgCMatrix")) {
    stop("Input must be a sparse dgCMatrix")
  }
  
  values <- sparseMat@x
  uniq_vals <- sort(unique(values))
  
  if (!all(as.character(uniq_vals) %in% names(code_map_epiallele))) {
    stop("Some matrix values do not appear in `code_map_epiallele`.\n",
         "Missing: ", paste(setdiff(as.character(uniq_vals),
                                    names(code_map_epiallele)), collapse=", "))
  }
  
  # Ricodifica 
  new_vals <- as.numeric(code_map_epiallele[as.character(values)])
  
  newMat <- sparseMat
  newMat@x <- new_vals
  
  methods::validObject(newMat)  
  
  newMat_dense <- as.matrix(newMat)
  newMat_df <- as.data.frame(newMat_dense)
  
  return(newMat_df)
}


get_out_ont=function(epi_df, out, strand, coord, myfuns)
{
  parameters=lapply(myfuns, function(x) { 
    ifelse(length(x) == 1, x(epi_df), x[[1]](epi_df, x[[2]]) )
    }
  )
  
  param_df <- as.data.frame(as.list(sapply(parameters, function(x) {
    if (length(x) > 1) paste(x, collapse = ",") else x
  })))
  
  mydata = data.frame(as.data.frame(coord), param_df)
  mydata$strand = strand
  
  out[["intervals"]] = mydata
  
  id = apply(mydata[1,c(1:3)] , 1 , function(x) paste(x,collapse="_"))
  epi_df$epi = apply(epi_df, 1, function(x) paste(x, collapse = ""))
  epi_df = as.data.frame(table(epi_df$epi))
  epi_df$id = id
  epi_df$strand = strand
  
  out[["epi"]] = epi_df
  
  return(out)
}

