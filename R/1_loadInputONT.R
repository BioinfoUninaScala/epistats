#' Loading Input data.
#'
#' @import Matrix
#' @import dplyr
#' @import stringr
#' @importFrom data.table fread
#' @importFrom GenomicRanges findOverlaps
#' @importFrom BSgenome getBSgenome
#' @param modkit_file 
#' Path to the TSV file generated by `modkit extract calls`.  
#' The file must contain the per-base modified base calls for each read, 
#' including reference position, strand, call code (e.g. m/h/u), call probability,
#' and other metadata exported by modkit.
#' @param read_coord_bedfile 
#' Path to a BED file containing genomic alignment coordinates for each read.  
#' Typically generated with:
#' `samtools view -b -F 2308 <bam> | bedtools bamtobed`.  
#' The file must include at least 6 columns (chr, start, end, readID, score, strand).
#' @param genome_assembly 
#' A genome reference used to extract CpG positions and check reference bases.  
#' Accepted values:  
#' - a **BSgenome object**,  
#' - the full package name of an installed BSgenome (e.g. `"BSgenome.Hsapiens.UCSC.hg38"`),  
#' - an **NCBI assembly name** (e.g. `"GRCh38"`),  
#' - a **UCSC assembly name** (e.g. `"hg38"`, `"mm10"`).  
#' If a character string is provided, the function attempts to load the 
#' corresponding BSgenome package automatically.
#' @param sel_chr 
#' Optional character vector specifying one or more chromosomes to include  
#' (e.g. `"chr21"` or `c("chr21", "chr22")`).  
#' If `NULL`, all chromosomes present in both input files are processed.
#' @param bases 
#' Character vector specifying which dinucleotide(s) or motif(s) to analyze.  
#' Default `"CG"` identifies CpG sites for 5mC/5hmC calling.  
#' Other motifs (e.g. `"CA"`, `"CT"`) can be used for alternative base modifications 
#' if present in the modkit output.
#' @param mapq_th 
#' Mapping quality threshold.  
#' Only reads with mapping quality >= `mapq_th` (from the BED column 5 or BAM MAPQ)  
#' are included.  
#' Default `0` keeps all reads.
#' @param base_qual_th 
#' Minimum base calling quality threshold for including a modified base.  
#' Corresponds to the `base_qual` column from `modkit extract calls`.  
#' Default `0` keeps all base calls.
#' @param output_file 
#' Optional path to save the generated list object (RDS format).  
#' If `NULL`, the object is only returned in memory.
#' @param code_map Named numeric vector that maps `call_code` values
#'   from the modkit output to integer codes used in the matrix.
#'   Names must correspond to possible values of the `call_code` column
#'   (e.g. "m", "h", "u", "c", "t", ...). A special name `"default"`
#'   can be provided and is used for any `call_code` that is not
#'   explicitly listed in `code_map`. For example:
#'   `code_map = c(default = 1L, m = 2L, h = 3L)` will assign:
#'   - 2 to `call_code == "m"`
#'   - 3 to `call_code == "h"`
#'   - 1 to all other codes.
#'   Values are stored as signed integers; if `ref_strand == "-"`,
#'   the value is multiplied by -1.
#' @param rm_zero_col Boolean value. When set to TRUE, zero columns are filtered out. Default value: FALSE.
#' @param nThread Number of threads used by data.table::fread() to load modkit_file and read_coord_bedfile.
#' @return A sparse matrix (Matrix::dgCMatrix) with reads in rows and genomic motif positions in columns.
#' @export


loadInputONT <- function(
    modkit_file,
    read_coord_bedfile,
    genome_assembly = 'hg38',
    sel_chr = NULL,
    bases = "CG",
    mapq_th = 0,
    base_qual_th = 0,
    output_file = NULL,
    code_map = c(default = 1L, m = 2L, h = 3L),
    rm_zero_col = FALSE,
    nThread = 8
) {
  
  check_bases(bases)
  check_code_map(code_map)
  
  genome <- load_genome(genome_assembly, sel_chr)
  base_coords_df <- get_coordinates(genome, bases, sel_chr)
  
  read_coords_df <- load_read_coords(
    read_coord_bedfile = read_coord_bedfile,
    mapq_th = mapq_th,
    sel_chr = sel_chr,
    nThread = nThread
  )
  
  mod_df <- load_modkit_calls(
    modkit_file = modkit_file,
    base_qual_th = base_qual_th,
    sel_chr = sel_chr,
    code_map = code_map, 
    nThread = nThread
  )
  
  check_consistency(read_coords_df, mod_df, base_coords_df)
  
  mat_base <- build_sparse_matrix(
    base_coords_df = base_coords_df,
    read_coords_df = read_coords_df,
    mod_df         = mod_df
  )
  
  f_mat_base <- filter_matrix(mat_base, rm_zero_col = rm_zero_col)
  
  if (!is.null(output_file)) {
    message("Saving filtered sparse matrix to: ", output_file)
    saveRDS(f_mat_base, output_file)
  }
  
  message("Completed!")
  return(f_mat_base)
}


check_bases <- function(bases) {
  if (length(bases) != 1L) {
    stop("`bases` must be a single string (e.g. 'CG').")
  }
}


check_code_map <- function(code_map) {
  code_map <- unlist(code_map)
  if (!("default" %in% names(code_map))) {
    stop("code_map must include a 'default' entry")
  }
  if (any(code_map == 0L)) {
    stop("code_map cannot contain 0. Sparse matrices treat 0 as 'no information'.")
  }
  if (any(code_map < 0L)) {
    stop("code_map cannot contain negative values. Negative strand values are assigned automatically.")
  }
  if (!is.numeric(code_map)) {
    stop("`code_map` must be a named numeric vector or list coercible to numeric.")
  }
}


load_genome <- function(genome_assembly, sel_chr) {
  message('Loading reference genome: ', genome_assembly, '...')
  if (inherits(genome_assembly, "BSgenome")) {
    genome <- genome_assembly
  } else if (is.character(genome_assembly) && length(genome_assembly) == 1L) {
    genome <- getBSgenome(genome_assembly, masked = FALSE, load.only = FALSE)
  } else {
    stop("genome_assembly must be either a BSgenome object or a single character string.")
  }
  
  chromosomes <- genome@seqinfo@seqnames
  if (!is.null(sel_chr)) {
    missing_chr <- sel_chr[! sel_chr %in% chromosomes]
    if (length(missing_chr) > 0L) {
      stop("These chromosomes are not present in the genome: ",
           paste(missing_chr, collapse = ", "))
    }
  }
  
  return(genome)
}


get_base_positions <- function(seq, bases = "CG") {
  seq <- as.character(seq)
  starts <- unlist(gregexpr(bases, seq, fixed = TRUE))
  starts[starts > 0]
}


get_coordinates <- function(genome, bases = "CG", sel_chr = NULL) {
  message('Extracting positions of ', bases, ' in the reference genome...')
  chromosomes <- genome@seqinfo@seqnames
  
  if (!is.null(sel_chr)) {
    chromosomes <- chromosomes[chromosomes %in% sel_chr]
  }
  if (length(chromosomes) == 0L) {
    stop("No chromosomes available for coordinate extraction.")
  }
  
  base_genome <- lapply(chromosomes, function(chr) { 
    pos <- get_base_positions(genome[[chr]], bases)
    if (length(pos) == 0L) return(NULL)
    data.frame(chr = chr, pos = pos)
  })
  
  base_genome <- do.call(rbind, base_genome)
  
  if (is.null(base_genome) || nrow(base_genome) == 0L) {
    stop("No '", bases, "' motifs found in the selected chromosomes.")
  }
  
  return(base_genome)
}


load_read_coords <- function(read_coord_bedfile,
                              mapq_th,
                              sel_chr = NULL,
                              nThread = data.table::getDTthreads()) {
  message("Reading reads coordinates from: ", read_coord_bedfile)
  
  read_coords <- data.table::fread(
    read_coord_bedfile,
    header      = FALSE,
    colClasses  = list(
      character = c("V1", "V4", "V6"),  # chr, readID, strand
      integer   = c("V2", "V3"),        # start, end
      numeric   = "V5"                  # score / MAPQ
    ),
    nThread     = nThread,
    showProgress = TRUE
  )
  
  if (ncol(read_coords) != 6L) {
    stop("The provided read_coord_bedfile must have 6 columns!")
  }
  if (nrow(read_coords) == 0L) {
    stop("read_coord_bedfile has 0 rows - nothing to process.")
  }
  if (!is.numeric(read_coords[["V5"]])) {
    stop("Column 5 of read_coord_bedfile (score/MAPQ) must be numeric.")
  }
  
  data.table::setDT(read_coords)
  data.table::setnames(read_coords,
                       old = paste0("V", 1:6),
                       new = c("chr", "start", "end", "readID", "score", "strand"))
  
  read_coords[, start := start + 1L]
  read_coords <- read_coords[score >= mapq_th]
  
  if (!is.null(sel_chr)) {
    read_coords <- read_coords[chr %in% sel_chr]
  }
  
  if (nrow(read_coords) == 0L) {
    stop("No reads left after filtering (MAPQ and/or chromosomes).")
  }
  
  return(read_coords)
}


load_modkit_calls <- function(modkit_file,
                               base_qual_th,
                               sel_chr = NULL,
                               code_map,
                               nThread = data.table::getDTthreads()) {
  message("Reading modkit calls from: ", modkit_file)
  
  required_cols <- c(
    "read_id", "chrom", "ref_position",
    "call_code", "base_qual", "ref_strand"
  )
  
  mod_file <- data.table::fread(
    modkit_file,
    select      = required_cols,
    colClasses  = "character", 
    nThread     = nThread,
    showProgress = TRUE
  )
  
  if (nrow(mod_file) == 0L) {
    stop("modkit_file has 0 rows - nothing to process.")
  }
  
  missing_cols <- setdiff(required_cols, names(mod_file))
  if (length(missing_cols) > 0L) {
    stop("The modkit file is missing required columns: ",
         paste(missing_cols, collapse = ", "))
  }
  
  data.table::setDT(mod_file)
  
  mod_file[, bad_refpos := !grepl("^[0-9]+$", ref_position)]
  
  n_bad <- mod_file[bad_refpos == TRUE, .N]
  if (n_bad > 0L) {
    message("   [NOTE] Removing ", n_bad,
            " rows with non-numeric ref_position (likely header lines).")
    print(mod_file[bad_refpos == TRUE])
    mod_file <- mod_file[bad_refpos == FALSE]
  }
  
  mod_file[, bad_refpos := NULL] 
  
  mod_file[, `:=`(
    base_qual    = as.integer(base_qual),
    ref_position = as.integer(ref_position)
  )]
  
  if (any(is.na(mod_file$ref_position))) {
    stop("Unexpected NA in ref_position after cleaning.")
  }
  if (any(is.na(mod_file$base_qual))) {
    stop("Unexpected NA in base_qual after cleaning.")
  }
  
  if (base_qual_th > 0L) {
    mod_file <- mod_file[base_qual >= base_qual_th]
  }
  if (nrow(mod_file) == 0L) {
    stop("No modkit calls pass base_qual >= ", base_qual_th, ".")
  }
  
  data.table::setnames(mod_file, "chrom", "chr")
  
  mod_file[, ref_position_0based := ref_position]
  
  mod_file[
    ,
    ref_position := data.table::fifelse(
      ref_strand == "-",
      ref_position_0based,
      ref_position_0based + 1
    )
  ]
  
  # base_key = chr_pos
  mod_file[, base_key := paste(chr, ref_position, sep = "_")]
  
  if (!is.null(sel_chr)) {
    mod_file <- mod_file[chr %in% sel_chr]
    if (nrow(mod_file) == 0L) {
      stop("No modkit calls on selected chromosomes: ",
           paste(sel_chr, collapse = ", "))
    }
  }
  
  # mapping call_code -> value tramite code_map
  val <- code_map[mod_file[["call_code"]]]
  unmapped <- is.na(val)
  if (any(unmapped)) {
    val[unmapped] <- code_map[["default"]]
  }
  mod_file[, value := as.integer(val)]
  
  return(mod_file[, .(read_id, chr, ref_position, base_key, value)])
}


check_consistency <- function(read_coords_df, mod_df, base_coords_df){
  
  message("Running consistency checks...")
  
  ## ---- 2. Chromosomes present in input files ----
  chr_bed <- unique(read_coords_df$chr)
  chr_mod <- unique(mod_df$chr)
  chr_ref <- unique(base_coords_df$chr)
  
  common_chr <- Reduce(intersect, list(chr_bed, chr_mod, chr_ref))
  
  if (length(common_chr) == 0L) {
    stop("No chromosomes in common among BED, modkit, and genome coordinates.")
  }
  
  cat("Common chromosomes between inputs: ", paste(common_chr, collapse = ", "), '\n')
  
  ## ---- 3. Read ID consistency ----
  missing_in_modkit <- setdiff(read_coords_df$readID, mod_df$read_id)
  missing_in_bed    <- setdiff(mod_df$read_id, read_coords_df$readID)
  
  if (length(missing_in_modkit) > 0L) {
    message("[WARN] Reads present in BED but not in modkit: ", 
            length(missing_in_modkit))
  }
  
  if (length(missing_in_bed) > 0L) {
    stop("Some modkit reads do not exist in BED: ",
         paste(head(missing_in_bed), collapse = ", "), " ...")
  }
  
  ## ---- 4. Positions of motifs ----
  if (nrow(base_coords_df) == 0L) {
    stop("No motif coordinates (e.g., CG) extracted from genome.")
  }
  
  ## ---- 5. Checks passed ----
  cat("Consistency checks passed.\n")
  return(invisible(TRUE))
}


build_sparse_matrix <- function(base_coords_df, read_coords_df, mod_df) {
  message('Building sparse matrix...')
  base_key   <- paste(base_coords_df$chr, base_coords_df$pos, sep = "_")
  base_index <- stats::setNames(seq_along(base_key), base_key)
  
  read_gr <- GRanges(
    seqnames = read_coords_df$chr,
    ranges   = IRanges::IRanges(start = read_coords_df$start,
                       end   = read_coords_df$end)
  )
  base_gr <- GRanges(
    seqnames = base_coords_df$chr,
    ranges   = IRanges::IRanges(start = base_coords_df$pos,
                       end   = base_coords_df$pos)
  )
  
  hits <- findOverlaps(read_gr, base_gr)
  i1 <- queryHits(hits)
  j1 <- subjectHits(hits)
  x1 <- rep(1L, length(i1))
  
  mat_base <- sparseMatrix(
    i = i1,
    j = j1,
    x = x1,
    dims = c(nrow(read_coords_df), nrow(base_coords_df)),
    dimnames = list(read_coords_df$readID, base_key)
  )
  
  # inserisco i valori modificati
  mod_df$col <- base_index[mod_df$base_key]
  cat('Number of modkit calls not present in reference sites: ', sum(is.na(mod_df$col)), '\n')
  
  f_mod_df   <- mod_df[!is.na(mod_df$col), ]
  
  read_index <- stats::setNames(seq_len(nrow(mat_base)), rownames(mat_base))
  f_mod_df$row <- read_index[f_mod_df$read_id]
  f_mod_df <- f_mod_df[!is.na(f_mod_df$row), ]
  
  mat_base[cbind(f_mod_df$row, f_mod_df$col)] <- f_mod_df$value
  
  message("Applying strand sign (fast)...")
  
  strand_sign <- ifelse(read_coords_df$strand == "+", 1L, -1L)
  mat_base <- mat_base * strand_sign
  
  return(mat_base)
}


filter_matrix <- function(mat_base, rm_zero_col = FALSE) {
  message('Filtering sparse matrix...')
  zero_rows <- rownames(mat_base)[rowSums(mat_base) == 0]
  f_mat_base <- mat_base[!(rownames(mat_base) %in% zero_rows), , drop = FALSE]
  
  if (rm_zero_col) {
    zero_cols <- colnames(f_mat_base)[colSums(f_mat_base) == 0]
    if (length(zero_cols) > 0L) {
      f_mat_base <- f_mat_base[, !(colnames(f_mat_base) %in% zero_cols), drop = FALSE]
    }
  }
  
  f_mat_base
}

