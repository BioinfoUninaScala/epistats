library(Biostrings)
library(parallel)
library(Rsamtools)
library(GenomicAlignments)
library(GenomeInfoDb)
library(future)
library(furrr)

#library(future.apply)
### Read Genome ----------------------------------------------------------------
# If it must be a function
readGenome <- function(GenomePath)
{
  cat("loading Genome from ", GenomePath, "...\n")
  Genome <- Biostrings::readDNAStringSet(GenomePath, format = "fasta")
  return(Genome)
}

### Read BAM -------------------------------------------------------------------
readBAM <- function(bamfile)
{
  cat("loading data from ", bamfile, "...\n")
  param <- Rsamtools::ScanBamParam(what = c("seq","strand"))
  algn <- GenomicAlignments::readGAlignments(bamfile,
                                             use.names=TRUE,
                                             param=param)
  return(algn)
}

### match Genome names with BAM names ------------------------------------------
matchGenomeWithBAM <- function(Genome,
                               algn)
{
  names(Genome)=GenomeInfoDb::seqlevels(algn)
  return(Genome)
}

### wrapper function to previous one -------------------------------------------
loadInput=function(bamfile,
                   genomefile)
{
  algn=readBAM(bamfile)
  Genome=readGenome(genomefile)
  if (length(intersect(seqlevels(algn), names(Genome))) == length(Genome))
  {
    cat("chromosome names in input files match.\n Loading data done!\n")
    return(list("algn"=algn, "genome"=Genome))
  }else{
    cat("chromosome names in input files do not correspond.\n Matching chromosome names...\n")
    if(!length(names(Genome)) == length(seqlevels(algn)))
    {
      cat("Error: number of chromosomes in Genome not match number of chromosomes in Bam File.\n Match of chromosome names impeeded!\n")
      return(list("algn"=algn, "genome"=Genome))
    }else{
      Genome=matchGenomeWithBAM(Genome,algn)
      cat("match of chromosome names done.\n Loading data done!\n")
      return(list("algn"=algn, "genome"=Genome))
    }
  }
}

### filterBAM ------------------------------------------------------------------
filterBAM <- function(algn,
                      keepStChr=TRUE,
                      keepM=FALSE,
                      retainChr=NULL)
{
  cat("filtering reads in bam\n" )
  if(!is.null(retainChr)==TRUE){
    cat("filtering reads that align to user provided intervals\n")
    algn <- GenomeInfoDb::keepSeqlevels(algn, retainChr, pruning.mode = "coarse")
    cat("done\n")
  } else {
    if(keepStChr==TRUE){
      cat("filtering reads that align to standard chromosomes\n")
      algn <- GenomeInfoDb::keepStandardChromosomes(algn, pruning.mode = "coarse")
      cat("done\n")
    }
    if(keepM==FALSE){
      cat("filtering reads that align to chr M \n")
      algn <- GenomeInfoDb::dropSeqlevels(algn, c("chrM","MT"), pruning.mode = "coarse")
      cat("done")
    }
  }
  return(algn)
}

### filterbyCoverage -----------------------------------------------------------
filterByCoverage <- function(algn,
                             threshold,
                             minsize)
{
  cat("filtering regions with minimum coverage", threshold, "\n")
  cvg <- GenomicAlignments::coverage(algn)                                      ### coverage per chr
  cvg <- GenomicRanges::GRanges(cvg)                                            ### estraggo i GRanges di queste regioni
  cvg <- cvg[cvg$score>=threshold]                                              ### seleziono i GRanges che hanno un n di reads(threshold) in particolare
  # cvg <- cvg[cvg$score <= quantile(cvg$score, probs=seq(0,1,0.01))[100]]
  cvg <- IRanges::reduce(cvg)                                                   ### unisco i GRanges contigui
  cvg=cvg[which(GenomicRanges::width(cvg)>= minsize)]                           ### elimino i ranges con width<1
  # cvg=split(cvg, seqnames(cvg))                                               ### split per cromosoma
  cat("done\n")
  return(cvg)
}

## findPattern -----------------------------------------------------------------
findPattern <- function(Genome, cores, mode="CG"){
  Pattern <- parallel::mclapply(GenomeInfoDb::seqlevels(Genome), function(x) GenomicRanges::start(Biostrings::matchPattern(mode, Genome[[x]])), mc.cores = cores)
  return(
    suppressWarnings(
      base::do.call(c, parallel::mclapply(1:length(GenomeInfoDb::seqlevels(Genome)), function(x) GenomicRanges::GRanges(base::names(Genome)[x],
                                                                                                                        IRanges::IRanges(Pattern[[x]], width = 2)
      ), mc.cores=cores))
    )
  )
}

##filterWindows ----------------------------------------------------------------
filterWindows = function(windows,
                         Genome,
                         mode,min.C,
                         max.C,
                         cores)
{
  ###find cmode coordinates in the Genome
  c_pos <- findPattern(Genome,cores=cores,mode=mode)
  #####filters windows with a number of cmode in the user supplied range
  windows_filt <- windows[GenomicRanges::countOverlaps(windows, c_pos)>=min.C]
  windows_filt <- windows_filt[GenomicRanges::countOverlaps(windows_filt, c_pos)<=max.C]
  #####select Cmode ranges that fall within the selected windows
  c_pos <- c_pos[GenomicRanges::countOverlaps(c_pos, windows_filt)>0]
  return(list("windows_filt"=windows_filt, "c_pos"=c_pos))
}


## findBins --------------------------------------------------------------------
findBins <- function(gr,
                     n)
{
  cat("processing", as.character(gr@seqnames@values), "\n")
  return(IRanges::IRanges(start = ranges(gr)@start[c(1:(length(gr)-n+1))],end=(ranges(gr)@start[c(n:length(gr))])+1,
                          names = rep(gr@seqnames@values, times= length(gr)-n+1)))
}

## findEpialleles
findEpialleles <- function(gr,
                           Genome,
                           mode,
                           n,
                           min.binsize,
                           max.binsize,
                           cores)
{
  ###find Cmode in Genome
  Genome=Genome[names(Genome) %in% seqlevels(gr)]
  cat("retrieving", mode, "coordinates from genomic sequence")
  c_pos= findPattern(Genome, cores=cores, mode)
  ###find overlaps between Cmode and intervals
  overlaps <- GenomicRanges::findOverlaps(gr, c_pos)
  #####select intervals with number of Cmode >=n
  gr_filt = gr[countQueryHits(overlaps) >= n]
  ###select only Cmode coord that overlap with the selected intervals
  c_filt = c_pos[GenomicRanges::countOverlaps(c_pos, gr_filt)>0]
  ####Find overlaps between filtered objects
  overlaps_filt <- GenomicRanges::findOverlaps(gr_filt, c_filt)
  ####add interval id to cpos. In this way cpg that overlap the same interval will share the same id
  c_filt$id <- queryHits(overlaps_filt)
  ####split cpos in list by interval id
  byint <- split(c_filt, f=c_filt$id)
  ####apply find bins function to each element of the list
  cat("finding epialleles in Genome \n")
  bins <- do.call(c,lapply(byint, function(x) findBins(x,n)))
  cat("done\n")
  ####unlist  bins
  bins=unlist(IRangesList(bins),use.names = FALSE)
  ####filter bins by size
  cat("filtering epialleles with max bin size", max.binsize, "and min bin size", min.binsize, "\n")
  bins=bins[bins@width<=max.binsize]
  bins=bins[bins@width>min.binsize]
  ###
  cat("done\n")
  bins=GRanges(seqnames = bins@NAMES, ranges= bins)
  c_pos<- c_filt[GenomicRanges::countOverlaps(c_filt, bins)>0]
  return(list("bins"= bins, "c_pos"=c_pos))
}

## MakeEpialleles --------------------------------------------------------------
makeEpialleles <- function(gr,
                           Genome,
                           mode="CG",
                           n=4,
                           min.binsize=1,
                           max.binsize=200,
                           cores=10)
{
  if(mode=="CG"){
    data= findEpialleles(gr, Genome, mode, n, min.binsize, max.binsize, cores)
    bins= data[[1]]
    c_pos= data[[2]]
  } else {
    data_plus= findEpialleles(gr, Genome, mode, n, min.binsize, max.binsize, cores)
    data_minus= findEpialleles(gr, Genome, mode= Biostrings::reverseComplement(Biostrings::DNAString(mode)), n, min.binsize, max.binsize, cores)
    bins= c(data_plus[[1]], data_minus[[1]])
    c_pos= c(data_plus[[2]], data_minus[[2]])
  }
  return(list("bins"=bins,"c_pos"=c_pos))
}

## MakeWindows -----------------------------------------------------------------
makeWindows <- function(gr, window, step, Genome, mode, min.C, max.C, cores){
  ##split gr in sliding windows
  windows <- GenomicRanges::slidingWindows(gr, window, step)
  if (mode=="CG")
  {
    data=filterWindows(windows@unlistData, Genome, mode, min.C, max.C, cores = cores)
    windows_filt=data[["windows_filt"]]
    c_pos=data[["c_pos"]]
  }else{
    data_plus <- filterWindows(windows@unlistData, Genome, mode, min.C, max.C, cores = cores)
    data_plus=lapply(data_plus, function(x) GenomicRanges::strand(x)="+")
    data_minus=filterWindows(windows@unlistData, Genome, Biostrings::reverseComplement(Biostrings::DNAString(mode)), min.C, max.C, cores = cores)
    data_minus=lapply(data_minus, function(x) GenomicRanges::strand(x)="-")
    ####unisce plus e minus
    c_pos=c(data_plus[["c_pos"]], data_minus[["cpos"]])
    windows_filt=c(data_plus[["windows_filt"]], data_minus[["windows_filt"]])
  }
  return(list("windows"=windows_filt, "c_pos"=c_pos))
}
