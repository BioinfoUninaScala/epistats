---
title: "Epistats"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
### 21-07-2021 

#### 1. **Data loading** 
```{r message=FALSE, warning=FALSE}
library(epistats)
```

First of all you need to load your data. To run the script you need a bam file containing your alignments and the reference genome used for the alignment. 


```{r warning=FALSE}
data = loadInput(bamfile="/home/condivisa_giulia/CML/out/ERR1227470_sorted.bam", genomefile = "/home/deriso/analysis/Genome/hg19/GRCh37.p13.genome.fa"  )
algn = data[[1]]
Genome = data[[2]]
```

#### 2. **Filtering BAM file**

After loading your data, your can decide to filter your alignment by taking only certain chromosomes, only standard chromosomes, etc...

```{r message = FALSE, warning = FALSE}
algn = filterBAM(algn = algn, 
                 keepStChr = TRUE, 
                 keepM = FALSE,
                 retainChr = NULL)
```

#### 3. **Filtering regions on the basis of their coverage**

The next step is to define GenomicRanges that satisfy a given value of coverage provided by user (trough the argument _threshold_). You can also set a minimum length size of your regions according to your read length sizes or your window levels (see point 5). 

```{r}
gr = filterByCoverage(algn, threshold = 50, minsize = 50)
```

#### 4. **Finding intervals to analyse**

Epistats provides two different methods to find the intervals you can extract the epiallels from. You can use _makeEpialleles()_ to produce genomic ranges of different length which all contain 4 CpGs. Otherwise, you can use _makeWindows()_ to produce sliding windows along the genome, which at the end will contain a different number of CpG. In the latter case, you can set arguments to decide the minimum and the maximum number of CpGs to be contained in the sliding windows. 

```{r}
bins = makeEpialleles(gr = gr, 
                      Genome = Genome, 
                      mode = "CG",
                      n = 4, 
                      min.binsize = 8, 
                      max.binsize = 50, 
                      cores = 10 )
bins = bins$bins
```

```{r}
slidingws = makeWindows(gr = gr, 
                        window = 50, 
                        step = 1, 
                        Genome = Genome, 
                        mode = "CG", 
                        min.C = 2, 
                        max.C = 10, 
                        cores = 10 )
```

#### 5. **Run the analysis**

Once you have the genomic regions to analyse, you can use the function to extract the epialleles information. 
The output is a list of 3 dataframes containing different information.

* Intervals: this dataframe contains your genomic regions with a set of statistics related to that specific epilocus: CpG mean dist, Shannon entropy, Number of CpGs, etc... 
* epi: a dataframe that is a compressed matrix containing the epialleles distributions of your regions
* log: a dataframe containing the regions that failed the analysis since they probably contained ambiguity in relation to its methylation information 

You can choose which functions have to be used to perform statistics on your intervals by putting them in a list given to the _epiAnalysis()_ function through the argument _myfuns =_. 

The function also writes all the three dataframes in the working directory specified through the argument _wd_. 

```{r echo = FALSE}
dist= function(matrix){
  Cpos=as.numeric(names(matrix))
  dist=round(mean(Cpos[-1]-Cpos[-length(Cpos)])/length(Cpos),2)
  return(dist)
}

epi= function(matrix){
  matrix$epi= apply(matrix, 1, function(x) paste(x, collapse = ""))
  matrix= as.data.frame(table(matrix$epi))
  epi=nrow(matrix)
  return(epi)
}

singleton= function(matrix){
  matrix$epi= apply(matrix, 1, function(x) paste(x, collapse = ""))
  matrix= as.data.frame(table(matrix$epi))
  singleton= length(matrix$Freq[matrix$Freq==1])
  return(singleton)
}

mean_met= function(matrix){
  mean_met=round(sum(as.matrix(matrix),na.rm=T)/(dim(matrix)[1]*dim(matrix)[2]),2)
  return(mean_met)
}

num_cg= function(matrix){
  num_cg=ncol(matrix)
  return(num_cg)
}

num_reads= function(matrix){
  num_reads=nrow(matrix)
  return(num_reads)
}

maxfreq= function(matrix){
  matrix$epi= apply(matrix, 1, function(x) paste(x, collapse = ""))
  matrix= as.data.frame(table(matrix$epi))
  maxfreq=paste(matrix[matrix$Freq==max(matrix$Freq),1],sep=",")
  return(maxfreq)
}

shannon= function(matrix){
  matrix$epi= apply(matrix, 1, function(x) paste(x, collapse = ""))
  matrix= as.data.frame(table(matrix$epi))
  prop= matrix$Freq/sum(matrix$Freq)
  shannon=round(-sum(prop * log2(prop), na.rm=T),2)
  return(shannon)
}

myfuns=list("dist"=dist,
            "epi"=epi, 
            "singleton"=singleton, 
            "maxfreq"=maxfreq,
            "shannon"=shannon,
            "mean_met"=mean_met,
            "num_cg"=num_cg,
            "num_reads"=num_reads)

```

```{r echo = FALSE}
wd = "/home/sarnataro/"
```

```{r error = TRUE}
aname = "ERR1227470"
out = epiAnalysis(align = algn, 
                  bin = bins, 
                  bisu.Thresh = 0,
                  stranded = FALSE, 
                  mode = "CG",
                  remove.Amb = TRUE, 
                  genome = Genome, 
                  pathDir = wd, 
                  cores = 50, 
                  retain.reads = TRUE, 
                  get.cPos = FALSE,
                  myfuns = myfuns)
```





